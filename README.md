###############################
Чтобы просмотреть список пользователей, которых вы создали, вы можете использовать команду `grep` совместно с командой `cat` для чтения файла `/etc/passwd`. Вот команда, которую вы можете использовать:

```bash
cat /etc/passwd | grep 'Created by [ваше_имя_пользователя]'
```

Здесь `[ваше_имя_пользователя]` - это ваше имя пользователя, которое вы использовали при создании пользователей.

Эта команда будет читать файл `/etc/passwd` и фильтровать строки, содержащие ваше имя пользователя в поле, отвечающем за создание пользователя. Таким образом, вы увидите только пользователей, которых вы создали.

Обратите внимание, что команда `grep` учитывает регистр, поэтому убедитесь, что вы вводите ваше имя пользователя точно так, как оно указано при создании пользователей.
###############################


###############################

Чтобы удалить пользователя в Linux, вы можете использовать команду `userdel`. Вот пример использования команды `userdel`:

```bash
sudo userdel username
```

Здесь `username` - это имя пользователя, которого вы хотите удалить.

При удалении пользователя команда `userdel` прекращает его существование в системе и удаляет его записи из файлов `/etc/passwd`, `/etc/shadow` и других системных файлов.

По умолчанию, команда `userdel` не удаляет домашнюю директорию пользователя и файлы, находящиеся в ней. Если вам нужно удалить домашнюю директорию и файлы пользователя, вы можете добавить опцию `-r`:

```bash
sudo userdel -r username
```

Эта опция указывает `userdel` удалить пользователя вместе с его домашней директорией и всеми файлами внутри нее.

Обратите внимание, что для выполнения этих команд потребуются привилегии администратора, поэтому используется команда `sudo`.

###############################

Это сообщение означает, что пользователь `lox` в данный момент используется процессом с идентификатором 1869. Процесс может быть каким-то активным приложением или службой, которые работают от имени этого пользователя.

Когда вы пытаетесь удалить пользователя, который используется процессом, операционная система не позволяет удалить пользователя до тех пор, пока все процессы, относящиеся к этому пользователю, не завершатся.

Чтобы удалить пользователя `lox`, вам нужно сначала завершить или прекратить все процессы, связанные с этим пользователем. Для этого вы можете использовать команду `kill`, чтобы отправить сигнал завершения процессу с указанным идентификатором:

```bash
sudo kill 1869
```

Здесь 1869 - идентификатор процЭто сообщение означает, что пользователь "lox" в данный момент используется процессом с идентификатором 1869. Это может быть активный процесс или служба, которая работает от имени этого пользователя.

Когда вы пытаетесь удалить пользователя, система не позволяет это сделать, пока все процессы, связанные с этим пользователем, не завершатся.

Для удаления пользователя "lox" вам необходимо прекратить или завершить процесс с идентификатором 1869. Для этого вы можете использовать команду `kill` с идентификатором процесса:

`sudo kill 1869`

После того, как процесс будет завершен, вы сможете удалить пользователя с помощью команды `userdel`. Обратите внимание, что для выполнения этих команд может потребоваться использование привилегий администратора (через `sudo`).

###############################

Если процесс не завершается после использования команды `kill`, возможно, это связано с тем, что процесс не реагирует на сигнал завершения (`SIGTERM`). В таком случае, вы можете попробовать отправить сигнал завершения более настойчивым способом, используя команду `kill` с опцией `-9`:

`sudo kill -9 1869`

Опция `-9` отправляет сигнал завершения (`SIGKILL`), который принудительно завершает процесс без возможности его обработки. Обратите внимание, что это наиболее настойчивый способ завершения процесса.

После того, как процесс завершен, вы можете повторить попытку удаления пользователя с помощью команды `userdel`:

`sudo userdel lox`

Если вы все еще получаете сообщение "user lox is currently used by process", убедитесь, что процесс действительно завершился, выполните команду `ps -p 1869` для проверки статуса процесса. Если процесс все еще активен, попробуйте отправить сигнал завершения с помощью команды `kill -9 1869` еще раз.

###############################

Чтобы предоставить новому пользователю права на создание и удаление папок и файлов, вы можете добавить его в группу с соответствующими разрешениями или изменить разрешения на конкретные папки и файлы.

Вариант 1: Добавление пользователя в группу
1. Создайте новую группу, если это необходимо. Например, `newgroup`.

`sudo groupadd newgroup`

2. Добавьте пользователя в созданную группу.

`sudo usermod -a -G newgroup username`

Здесь `username` - это имя нового пользователя, а `newgroup` - имя созданной вами группы.
3. Установите права на папки и файлы для группы `newgroup`. Предположим, что вы хотите предоставить полные права на папку `/path/to/folder` и ее содержимое:

`sudo chown -R :newgroup /path/to/folder`
`sudo chmod -R g+rwx /path/to/folder`

Групповой владелец (`:`) устанавливается на `newgroup`, а `g+rwx` предоставляет права на чтение, запись и выполнение группе `newgroup`.

Вариант 2: Изменение разрешений на папки и файлы
1. Установите права на папки и файлы непосредственно для пользователя. Предположим, что вы хотите предоставить полные права на папку `/path/to/folder` и ее содержимое для пользователя `username`:

`sudo chown -R username /path/to/folder`
`sudo chmod -R u+rwx /path/to/folder`

Владелец (`u`) устанавливается на `username`, а `u+rwx` предоставляет пользователю права на чтение, запись и выполнение.

Оба варианта могут быть использованы в зависимости от ваших потребностей и предпочтений. Убедитесь, что вы предоставляете только необходимые права для безопасности системы и данных.

###############################

Конечно! Давайте расшифруем команды, которые были представлены:

1. `sudo usermod -a -G newgroup username`

   - `sudo`: Это команда, которая позволяет выполнить следующую команду от имени суперпользователя (администратора), чтобы получить необходимые привилегии.
   - `usermod`: Команда `usermod` используется для изменения настроек пользователя.
   - `-a`: Опция `-a` указывает, чтобы пользователь был добавлен к группе, не заменяя его текущие принадлежности к другим группам.
   - `-G newgroup`: Опция `-G` указывает группу, к которой нужно добавить пользователя. В данном случае `newgroup` - это имя группы, в которую будет добавлен пользователь.
   - `username`: Это имя пользователя, которое будет добавлено в группу `newgroup`.

   Команда `sudo usermod -a -G newgroup username` добавляет пользователя `username` в группу `newgroup`. Это позволяет пользователю получить разрешения и привилегии, связанные с этой группой.

2. `sudo chown -R :newgroup /path/to/folder`

   - `sudo`: Как и ранее, это команда, которая предоставляет привилегии суперпользователя для выполнения команды.
   - `chown`: Эта команда используется для изменения владельца файла или папки.
   - `-R`: Опция `-R` указывает, что изменение владельца должно быть рекурсивным, то есть применяться ко всем файлам и папкам внутри указанной папки.
   - `:newgroup`: Двоеточие (`:`) перед именем группы указывает, что нужно изменить группу, но оставить владельца без изменений. `newgroup` - это имя группы, которую мы хотим установить.
   - `/path/to/folder`: Это путь к папке, для которой мы хотим изменить владельца и группу.

   Команда `sudo chown -R :newgroup /path/to/folder` устанавливает группу `newgroup` владельцем для папки `/path/to/folder` и всех файлов и подпапок внутри нее.

3. `sudo chmod -R g+rwx /path/to/folder`

   - `sudo`: Команда `sudo` предоставляет привилегии суперпользователя для выполнения команды.
   - `chmod`: Команда `chmod` используется для изменения прав доступа к файлам и папкам.
   - `-R`: Опция `-R` указывает, что изменение прав доступа должно быть рекурсивным, применяться ко всем файлам и папкам внутри указанной папки.
   - `g+rwx`: Это устанавливает права для группы. `g` означает группу, `+rwx` предоставляет права на чтение, запись и выполнение группе.
   - `/path/to/folder`: Это путь к папке, для которой мы хотим изменить права доступа.

   Команда `sudo chmod -R g+rwx /path/to/folder` устанавливает права чтения, записи и выполнения для группы на папку `/path/to/folder` и все ее содержимое (файлы и подпапки).

   В результате этих команд, пользователь `username` будет добавлен в группу `newgroup`, а папка `/path/to/folder` и все ее содержимое будут иметь группу `newgroup` владельцем и права чтения, записи и выполнения для группы. Это позволит пользователю `username` создавать и удалять файлы иКонечно! Давайте расшифруем команды, которые были представлены:

1. `sudo usermod -a -G newgroup username`

   - `sudo`: Это команда, которая позволяет выполнить следующую команду от имени суперпользователя (администратора), чтобы получить необходимые привилегии.
   - `usermod`: Команда `usermod` используется для изменения настроек пользователя.
   - `-a`: Опция `-a` указывает, чтобы пользователь был добавлен к группе, не заменяя его текущие принадлежности к другим группам.
   - `-G newgroup`: Опция `-G` указывает группу, к которой нужно добавить пользователя. В данном случае `newgroup` - это имя группы, в которую будет добавлен пользователь.
   - `username`: Это имя пользователя, которое будет добавлено в группу `newgroup`.

   Команда `sudo usermod -a -G newgroup username` добавляет пользователя `username` в группу `newgroup`. Это позволяет пользователю получить разрешения и привилегии, связанные с этой группой.

2. `sudo chown -R :newgroup /path/to/folder`

   - `sudo`: Как и ранее, это команда, которая предоставляет привилегии суперпользователя для выполнения команды.
   - `chown`: Эта команда используется для изменения владельца файла или папки.
   - `-R`: Опция `-R` указывает, что изменение владельца должно быть рекурсивным, то есть применяться ко всем файлам и папкам внутри указанной папки.
   - `:newgroup`: Двоеточие (`:`) перед именем группы указывает, что нужно изменить группу, но оставить владельца без изменений. `newgroup` - это имя группы, которую мы хотим установить.
   - `/path/to/folder`: Это путь к папке, для которой мы хотим изменить владельца и группу.

   Команда `sudo chown -R :newgroup /path/to/folder` устанавливает группу `newgroup` владельцем для папки `/path/to/folder` и всех файлов и подпапок внутри нее.

3. `sudo chmod -R g+rwx /path/to/folder`

   - `sudo`: Команда `sudo` предоставляет привилегии суперпользователя для выполнения команды.
   - `chmod`: Команда `chmod` используется для изменения прав доступа к файлам и папкам.
   - `-R`: Опция `-R` указывает, что изменение прав доступа должно быть рекурсивным, применяться ко всем файлам и папкам внутри указанной папки.
   - `g+rwx`: Это устанавливает права для группы. `g` означает группу, `+rwx` предоставляет права на чтение, запись и выполнение группе.
   - `/path/to/folder`: Это путь к папке, для которой мы хотим изменить права доступа.

   Команда `sudo chmod -R g+rwx /path/to/folder` устанавливает права чтения, записи и выполнения для группы на папку `/path/to/folder` и все ее содержимое (файлы и подпапки).

   В результате этих команд, пользователь `username` будет добавлен в группу `newgroup`, а папка `/path/to/folder` и все ее содержимое будут иметь группу `newgroup` владельцем и права чтения, записи и выполнения для группы. Это позволит пользователю `username` создавать и удалять файлы и

###############################

Чтобы установить Docker на виртуальной машине VPS (Virtual Private Server), следуйте инструкциям ниже:

1. Войдите в свою виртуальную машину VPS с помощью SSH-клиента или другого доступного средства удаленного подключения.

2. Обновите системные пакеты, выполнив следующую команду:
   ````
   sudo apt update
   ```

3. Установите необходимые пакеты, которые позволят вам загружать пакеты по HTTPS:
   ````
   sudo apt install apt-transport-https ca-certificates curl software-properties-common
   ```

4. Добавьте официальный GPG-ключ Docker:
   ````
   curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
   ```

5. Добавьте официальный репозиторий Docker:
   ````
   echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
   ```

6. Обновите информацию о пакетах:
   `sudo apt update`

7. Установите Docker:
   `sudo apt install docker-ce docker-ce-cli containerd.io`

8. После завершения установки Docker добавьте своего пользователя в группу `docker`, чтобы иметь возможность запускать команды Docker без использования `sudo`:
   `sudo usermod -aG docker $USER`

9. Выйдите из текущего сеанса SSH и повторно войдите в систему, чтобы изменения вступили в силу.

Теперь Docker должен быть установлен и готов к использованию на вашей виртуальной машине VPS. Вы можете проверить его, выполнив команду:
`docker version`

Она должна вывести информацию о версии Docker, если установка прошла успешно.

###############################

Чтобы просмотреть список групп в Linux и удалить группу, выполните следующие шаги:

1. Просмотр списка групп:
   - Чтобы просмотреть список всех групп в системе, выполните команду:
     ```
     cat /etc/group
     ```

   - Чтобы просмотреть список групп, к которым принадлежит определенный пользователь, выполните команду, заменив `<имя_пользователя>` на фактическое имя пользователя:
     ```
     groups <имя_пользователя>
     ```

2. Удаление группы:
   - Чтобы удалить группу, используйте команду `groupdel`, указав имя удаляемой группы. Например:
     ```
     sudo groupdel <имя_группы>
     ```

     Замените `<имя_группы>` на фактическое имя группы, которую вы хотите удалить.

   - При удалении группы также может потребоваться удалить соответствующий ей домашний каталог и/или перенести файлы пользователей в другую группу. Это зависит от конкретного случая использования и требований вашей системы.

При выполнении операций удаления групп будьте осторожны, убедитесь, что вы удаляете нужную группу и что удаление группы не повлияет на другие пользователей или системные процессы, которые могут использовать эту группу.

###############################

Если вашему созданному пользователю не назначены права sudo, вам потребуется выполнить следующие шаги, чтобы предоставить ему эти права:

1. Войдите в виртуальную машину VPS от имени пользователя root или другого пользователя с правами sudo.

2. Выполните следующую команду, чтобы отредактировать файл `/etc/sudoers` с помощью утилиты `visudo`:
   `sudo visudo`

3. В открывшемся редакторе найдите строку, содержащую определения прав доступа пользователей (User privilege specification). Обычно она выглядит следующим образом:
   `root    ALL=(ALL:ALL) ALL`

4. Добавьте следующую строку под этой строкой, чтобы предоставить права sudo вашему созданному пользователю (замените `<имя_пользователя>` на фактическое имя созданного пользователя):
   `<имя_пользователя>    ALL=(ALL:ALL) ALL`

   Например:
   `john    ALL=(ALL:ALL) ALL`

5. Сохраните изменения и закройте редактор.

Теперь ваш созданный пользователь должен иметь права sudo. Попробуйте выполнить команду `sudo -l -U <имя_пользователя>`, чтобы проверить, что права sudo назначены корректно.

###############################

Чтобы проверить, имеет ли созданный пользователь права sudo, вы можете выполнить следующую команду:

```
sudo -l -U <имя_пользователя>
```

Замените `<имя_пользователя>` на имя конкретного пользователя, для которого вы хотите проверить права sudo. Если пользователь имеет права sudo, команда выведет список разрешенных команд или информацию о том, что пользователь не имеет прав на выполнение команд от имени суперпользователя.

Относительно пароля: при выполнении команд с префиксом `sudo` система запросит пароль пользователя, от имени которого вы пытаетесь выполнить команду. Если пользователь имеет права sudo, он должен ввести свой собственный пароль.

Поскольку пароли пользователей хранятся в зашифрованном виде, вам не удастся просмотреть пароль созданного пользователя. Если вы забыли пароль, вы можете сбросить его, выполнив следующие шаги:

1. Зайдите в систему от имени пользователя root или другого пользователя с правами sudo.

2. Выполните следующую команду для сброса пароля созданного пользователя (замените `<имя_пользователя>` на фактическое имя созданного пользователя):
   ````
   sudo passwd <имя_пользователя>
   ```

3. Следуйте инструкциям и введите новый пароль для пользователя.

После выполнения этих шагов пароль созданного пользователя будет изменен на новый.

###############################

Рекомендуется выполнять установку Docker через пользователя с правами sudo, а не через пользователя root. Это обеспечит более безопасное использование Docker и предотвратит потенциальные ошибки, которые могут возникнуть при работе от имени пользователя root.

Выполните следующие шаги для установки Docker через пользователя с правами sudo:

1. Войдите в виртуальную машину VPS от имени пользователя с правами sudo с помощью SSH-клиента или другого доступного средства удаленного подключения.

2. Следуйте инструкциям, указанным в предыдущем ответе, начиная с шага 2 и выполняя команды с префиксом `sudo`. Например:
   `````
   sudo apt update
   sudo apt install apt-transport-https ca-certificates curl software-properties-common
   ```

3. Продолжайте следовать инструкциям, выполняя команды с префиксом `sudo`:
   ````
   sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
   sudo echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
   sudo apt update
   sudo apt install docker-ce docker-ce

###############################

Для создания файла через командную строку в Linux вы можете использовать команду `touch`. Вот примеры использования команд~ы `touch`:

1. Создание пустого файла:
   ````
   touch имя_файла
   ```

   Замените `имя_файла` на имя файла, который вы хотите создать. Например:
   ````
   touch example.txt
   ```

   Если указанный файл уже существует, команда `touch` обновит время последнего доступа к файлу, но не изменит его содержимое.

2. Создание нескольких файлов одновременно:
   ````
   touch имя_файла1 имя_файла2 имя_файла3
   ```

   Можно указать несколько имен файлов через пробел. Например:
   ````
   touch file1.txt file2.txt file3.txt
   ```

3. Создание файла с указанием пути:
   ````
   touch путь/имя_файла
   ```

   Можно указать путь к файлу вместе с его именем. Например:
   ````
   touch /home/user/example.txt
   ```

   В этом примере файл `example.txt` будет создан в каталоге `/home/user/`.

Команда `touch` создает файлы, если они не существуют, или обновляет время доступа к существующим файлам. Если вы хотите создать файл с определенным содержимым, можно использовать другие команды, такие как `echo` или `printf`, вместе с перенаправлением вывода в файл.

###############################
Установка DOCKER на VSC
`curl -fsSL https://get.docker.com -o get-docker.sh`

Что бы добавить пользователя в группу docker
`sudo usermod -aG docker lox`
###############################
Присваивает только группу для вего что находится по дир.(файлы и папки)
`sudo chown :proger *`
###############################
Проверить до какого (дата) сертификат действителен
`openssl x509 -enddate -noout -in cert.pem`

###############################
Показывает права к дир. или файлу
`ls -l ../dir/`
###############################

`sudo chown -h :proger`

###############################

Команда chown используется для изменения владельца и/или группы файлов и директорий в операционной системе Linux. Давайте разберемся в каждой команде по отдельности:

`chown -R root:root:`

-R означает рекурсивное изменение владельца и группы для всех файлов и поддиректорий в указанной директории.
root:root указывает, что владельцем и группой будет пользователь root. В данном случае оба значения равны root.


`chmod ug+rx:`

u означает владельца файла или директории.
g означает группу файла или директории.
+rx добавляет права на чтение (r) и выполнение (x) для владельца и группы. Это означает, что владелец и члены группы смогут читать и выполнять файлы или директории.


`sudo chown -h :proger:`

-h означает изменение владельца и группы символической ссылки, а не целевого файла или директории, на которую она ссылается.
:proger указывает, что группа будет изменена на proger. В данном случае пустое значение перед двоеточием означает, что владелец останется неизменным.


`sudo chown :proger:`

:proger указывает, что только группа будет изменена на proger. В данном случае пустое значение перед двоеточием означает, что владелец останется неизменным.

Итак, основное различие между командами chown и chmod состоит в том, что chown изменяет владельца и/или группу файла или директории, в то время как chmod изменяет права доступа к файлам и директориям. Каждая команда имеет свои опции и аргументы, которые позволяют управлять конкретными аспектами доступа и владения файлами.

######


Проверьте состояние брандмауэра на вашем VPS. В разных операционных системах и конфигурациях это может отличаться. Ниже приведены инструкции для некоторых популярных операционных систем.

Для Linux с использованием iptables:
Выполните команду `iptables -L` или `iptables -S` для просмотра текущих правил брандмауэра.

На основе вывода команды `iptables -L`, видно, что текущая конфигурация брандмауэра не содержит правил для открытия порта 8000.

Для открытия порта 8000 вы можете выполнить следующую команду:

```bash
iptables -A INPUT -p tcp --dport 8000 -j ACCEPT
```

После выполнения этой команды правило будет добавлено в цепочку INPUT, разрешая входящие соединения на порт 8000.

Проверьте вывод команды `iptables -L` после добавления правила, чтобы убедиться, что оно было успешно добавлено и установлено.

Обратите внимание, что эти изменения в брандмауэре могут быть временными и могут сброситься после перезагрузки системы. Чтобы сохранить изменения, вам нужно будет применить их с использованием соответствующих инструментов для вашей операционной системы (например, сохранить правила iptables в файл или использовать инструменты для сохранения конфигурации брандмауэра).

Да, если вы хотите откатить настройку открытия порта 8000 (`iptables -A INPUT -p tcp --dport 8000 -j ACCEPT`), вы можете использовать следующую команду:

```
iptables -D INPUT -p tcp --dport 8000 -j ACCEPT
```

Команда `iptables -D` удаляет правило из цепочки. В данном случае мы удаляем правило, открывающее порт 8000 для TCP-трафика в цепочке INPUT.

После выполнения этой команды правило открывающее порт 8000 будет удалено, и трафик на этот порт будет заблокирован, если нет других правил, разрешающих этот трафик.

Убедитесь, что вы выполняете эту команду с достаточными привилегиями (например, с использованием учетной записи с правами суперпользователя или с использованием команды `sudo`), чтобы иметь доступ к настройкам IP-таблицы.

Пожалуйста, обратите внимание, что изменение правил IP-таблицы может повлиять на сетевую доступность и безопасность вашего сервера. Убедитесь, что вы понимаете последствия таких изменений и принимайте меры предосторожности при внесении изменений в настройки IP-таблицы.


######
Если вы удалили опцию `:ro` из строки монтирования конфигурационного файла Nginx, то вы можете отредактировать файл `nginx.conf` и убрать или изменить блок `location /api`, если вам больше не требуется проксирование на `http://localhost:8000`. После внесения изменений в `nginx.conf`, перезапустите контейнеры, чтобы применить новую конфигурацию.

Что касается правила iptables, которое открывает порт 8000, вы можете использовать команду iptables для удаления этого правила. Вот пример команды для удаления правила:

```
iptables -D INPUT -p tcp --dport 8000 -j ACCEPT
```

Эта команда удалит правило, которое разрешает входящий трафик на порту 8000. Убедитесь, что вы выполняете эту команду с правами суперпользователя (например, используя `sudo`) и что правило действительно существует перед его удалением.

Обратите внимание, что если вы хотите сохранить изменения в `docker-compose.yaml`, то после внесения изменений в файл необходимо перезапустить контейнеры с помощью `docker-compose up -d`, чтобы применить новую конфигурацию.

######
в конце ro означает `read only`
`volumes:`
      `- ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro`


######

Команда `sudo apt-get install php-mysql` предназначена для установки расширения PHP для работы с базами данных MySQL. Если у вас уже установлено это расширение и вам не требуется его изменение или удаление, то нет необходимости выполнять эту команду.

Если вы случайно установили расширение и хотите его удалить, вы можете воспользоваться командой `sudo apt-get remove php-mysql` для удаления расширения PHP для MySQL.

Однако, учтите, что удаление расширения может повлиять на работу приложений, которые зависят от этого расширения. Убедитесь, что вы не используете расширение PHP для MySQL в своих проектах, прежде чем его удалять.

######

Чтобы просмотреть данные о расходе оперативной памяти в Linux, можно использовать различные инструменты. Некоторые из них включают:

1. Команда `free`: Команда `free` позволяет просмотреть общий объем оперативной памяти, используемый, свободный и другие связанные данные. Выполните `free -h` для отображения данных в более удобочитаемом формате.

2. Команда `top`: Команда `top` показывает текущую статистику использования системных ресурсов, включая оперативную память. Откройте терминал и выполните `top`, затем нажмите клавишу `m` (по умолчанию) для сортировки процессов по использованию памяти.

3. Команда `htop`: `htop` - это улучшенная версия команды `top` с более удобным интерфейсом. Выполните `htop` в терминале, чтобы открыть его. Используйте стрелки для перемещения и просмотра информации о памяти.

OMM-killer срабатывает, когда системе не хватает оперативной памяти для выполнения процессов. Он автоматически завершает определенные процессы, чтобы освободить память и предотвратить сбой системы.

RAM (Random Access Memory) и CPU (Central Processing Unit) - это разные компоненты компьютерной системы. RAM - это физическая память, используемая для хранения данных и кода, которые активно используются программами во время их выполнения. CPU - это центральный процессор, который выполняет инструкции и обрабатывает данные, в том числе данные, хранящиеся в оперативной памяти.

Swap (подкачка) - это механизм в операционной системе Linux, который позволяет использовать часть жесткого диска в качестве виртуальной памяти, когда физическая оперативная память исчерпывается. Если системе не хватает оперативной памяти, неиспользуемые данные могут быть перенесены на своп-раздел (swap partition) или своп-файл (swap file) на диске.

Меры проверки для решения проблемы нехватки оперативной памяти:

1. Анализ процессов: Используйте инструменты, такие как `top` или `htop`, чтобы определить, какие процессы потребляют больше всего памяти. Убедитесь, что нет процессов, которые ненормально расходуют память или утечек памяти.

2. Оптимизация приложений: Проверьте настройки и код ваших приложений, чтобы убедиться, что они эффективно используют память. Используйте средства профилирования и мониторинга, чтобы идентифицировать и исправить проблемы с памятью.

3. Увеличение оперативной памяти: Рассмотрите возможность увеличения объема оперативной памяти в вашей системе, если постоянно испытываете нехватку памяти. Это может включать добавление модулей памяти или увеличение объема памяти в виртуальной машине.

4. Настройка раздела подкачки: Если вашей системе требуетсяподкачка, но она не настроена или её размер недостаточен, рассмотрите возможность создания и настройки своп-раздела или своп-файла. Своп-раздел или своп-файл могут помочь обрабатывать временное использование памяти, когда физическая память исчерпывается.

5. Оптимизация системы: Проверьте настройки системы и ядра операционной системы. Некоторые параметры, такие как размер стека или лимиты памяти для процессов, могут быть настроены для более эффективного использования памяти.

6. Мониторинг ресурсов: Используйте мониторинговые инструменты, чтобы постоянно отслеживать использование оперативной памяти и других системных ресурсов. Это поможет вам обнаружить любые проблемы с памятью и принять соответствующие меры.

Важно помнить, что решение проблемы нехватки оперативной памяти может варьироваться в зависимости от конкретной системы и сценария использования. Рекомендуется изучить документацию и руководства, специфичные для вашей операционной системы и окружения, для получения более подробной информации и рекомендаций.


######

Для удаления всех образов Docker с вашей системы можно использовать команду `docker rmi`. Вот как вы можете выполнить эту операцию:

1. Откройте терминал или командную строку.

2. Запустите команду `docker images` для просмотра списка всех образов Docker на вашей системе. Вывод будет содержать столбцы с информацией об идентификаторе образа (Image ID), теге (Tag), размере (Size) и т. д.

3. Чтобы удалить все образы, выполните следующую команду:
   ````
   docker rmi $(docker images -q)
   ```

   Эта команда использует команду `docker images -q`, чтобы получить только идентификаторы образов, а затем передает их в команду `docker rmi`, которая удаляет каждый образ по его идентификатору.

4. Подтвердите удаление образов, если вам будет предложено это сделать. Каждый образ будет запрошен для подтверждения удаления.

Обратите внимание, что удаление образов Docker является необратимой операцией, и вы не сможете восстановить удаленные образы без их повторной загрузки из удаленного реестра Docker или из сохраненных локальных копий.

Также имейте в виду, что для выполнения этих действий вам потребуются соответствующие привилегии пользователя. Убедитесь, что вы выполняете команды от имени пользователя с достаточными правами или используйте `sudo`, если это необходимо.


######
чтобы определить, какие процессы потребляют память на вашей системе.
`docker stats`




#############################

1. Я создал новую VPS машину с другой локацией (KZ) перенёс с старой машины только дир. /home

В новой машине мне нужно:
   [+] создать пользователя
      ['adduser lox'] +
      проверить что есть в списке ['cat /etc/passwd'] +

   [+] создать для нового пользователя группу
      ['groupadd dev'] +
      проверить что есть в списке ['cat /etc/group'] +

   [+] добавить нового пользователя в новую группу
      ['sudo usermod -a -G dev lox'] +

   [+] предоставить права на дир. /home/lox/www/html
      ['chown -R :dev /home/lox/www/html'] - для группы +
      ['chown -R lox /home/lox/www/html']  - для пользователя

   [+] предоставить права на чтение,запись,выполнение группе
      ['chmod -R g+rwx /home/lox/www/html'] - для группы +
      ['chmod -R u+rwx /home/lox/www/html'] - для пользователя

   [+] предоставить ему права админа sudo
      ['visudo']
         -> ['#User privilege specification']
         -> ['lox ALL=(ALL:ALL) ALL']
         -> ['Sava']
         -> ['Enter']
      [+] проверка права на 'sudo'
         ['sudo -l -U lox']

   [+] настроить автоподключение по SSH без ввода паролея
      ['ssh-keygen -t rsa']   -> local OS - 'or' - ['ssh-copy-id root@5.35.81.99'] -> local OS
      ['type C:\Users\sme07\.ssh\id_rsa.pub'] - for windows
      ['ssh root@5.35.81.99'] -> local OS ['password: qDH9*aJ5nzU0']
      ['cd ~/.ssh'] - dir. vps SSH
      ['echo "" > ~/.ssh/authorized_keys'] - clean file authorized_keys
      ['cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys']
      ['chmod 600 ~/.ssh/authorized_keys']
      ['Restart SSH']


   [+] установить докер в машину
      ['sudo apt update']
      ['sudo apt install apt-transport-https ca-certificates curl software-properties-common']
      ['curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg']
      ['echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null']
      ['sudo apt update']
      ['sudo apt install docker-ce docker-ce-cli containerd.io']
      ['sudo usermod -aG docker lox']


   # посмотреть к какоим группам относится пользователь:
      ['groups lox']
   # create dir/
      ['mkdir html']
   # create file/
      ['touch README']
   # move dir or files/
      ['mv ex.file /html']
   # check usefull ports | example port :443
      ['sudo lsof -i :443']
   # kill user port | PID - identificator processing (PID)
      ['sudo kill -9 <PID>']
   # Используется для проверки состояния и доступности сервера Nginx.
   # Она показывает количество запросов, подключений и ошибок, с которыми Nginx справляется, а также использование CPU и памяти,
   # а также статус балансировки нагрузки и устойчивости к сбоям
      ['nginx -t']

   # Connect with MySQL from terminal
      ['mysql -h 127.0.0.1 -P 3306 -u bot_test -p']
   # COMMANDS
      ['SHOW DATABASES;', 'SHOW TABLES;']
      ['SHOW GRANTS FOR "user_name"@"%"']
   # Download modules for php in terminal
      ['php -m']

   [+] установка NGINX на машину
      ['sudo apt install nginx-core']


   [+] установка SSL сертификата для HTTPS
      ['https://certbot.eff.org/instructions?ws=nginx&os=ubuntufocal'] - information
      ['sudo apt-get remove certbot'] - before delete old certbot before to install new
      ['sudo apt-get install snapd']
      ['sudo snap install --classic certbot']
      ['sudo ln -s /snap/bin/certbot /usr/bin/certbot']
      ['sudo certbot --nginx'] or ['sudo certbot certonly --nginx']
      ['sudo certbot renew --dry-run']

   [+] поднять БД
   ['.env->DB_HOST=5.35.81.99']

   [+] запустить проект
   ['sudo apt install php8.1-cli']
   ['sudo apt install composer']

   - поставить свой VPN

   [+] поставить tailwind css ('Dokcer')
      ['https://tailwindcss.com/docs/guides/laravel']
         [+] поставить Node.js ('VPS|Docker')
            ['apt install node'] - 'for VPS and Docker(on php.Dockerfile)'
            ['node -v'] - 'check version'

   - запустить vite или npm run dev на VPS и Docker-e

   - создать репозиторий на GitHub
      # Инициализация Git в проекте /src
         ['git init']
         ['git add .']
         ['git commit -m first commit']
         ['git remote add origin https://github.com/Gambi99/TeleBot.git']
         ['git push -u origin master']
         ['chmod +x /root/.vscode-server/cli/servers/Stable-863d2581ecda6849923a2118d93a088b0745d9d6/server/extensions/git/dist/askpass.sh']
      ### ### ## Не помогло - ограничения в правах и всё в этом роде ## ### ###
      ## Откатываю всё обратно:
         ['git remote remove origin']
         ['git reset --hard HEAD~1']
         ['rm -rf .git']
         ['sudo chmod -x /root/.vscode-server/cli/servers/Stable-863d2581ecda6849923a2118d93a088b0745d9d6/server/extensions/git/dist/askpass.sh']

### JOBs ###
   # Установка и настройка Supervisor
      ['sudo apt-get install supervisor']
   # конфигурации Supervisor в директории
      ['/etc/supervisor/conf.d']
   # Назовите его, например, laravel-worker.conf
      ['laravel-worker.conf']
   # Добавьте следующее содержимое
      ['
         [program:laravel-worker]
         process_name=%(program_name)s_%(process_num)02d
         command=php /home/lox/html/src/artisan queue:work --tries=3
         autostart=true
         autorestart=true
         user=lox
         numprocs=8
         redirect_stderr=true
         stdout_logfile=/home/lox/html/src/worker.log
      ']
   # Команды для проверки Supervisor:
      ['sudo supervisorctl status']
      ['sudo supervisorctl stop laravel-worker:*']
      ['sudo supervisorctl stop all']
      ['sudo supervisorctl start all']
   # Laravel команда для запуска Job-a
      ['php artisan queue:work']

   # Check from terminal modules
      # Example:
      ['php -m | grep pdo_mysql']
   # Fix bug with mysql drivers
      ['sudo apt-get install php-mysql']

   # SQL
   ['ISNERT INTO TABLE_NAME (COLUMN1) VALUES (VALUE1)']

   # PHP Artisan
      # create seeders
      ['php artisan make:seeder TriggersTableSeeder']
      # generate and migrate seeders
      ['php artisan db:seed --class=TriggersTableSeeder']

   # FOREIGN KEY

   ['
      CREATE TABLE "orders" (
         `id` BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
         `user_id` BIGINT UNSIGNED

      FOREIGN KEY (`user_id`) REFERENCES `users`(`id`)
      ON DELETE CASCADE
      )
   ']

   # Laravel Forign key

   ["
      
   Schema::table('missions', function (Blueprint $table) {
    $table->unsignedBigInteger('user_id'); // создаем столбец для внешнего ключа

    $table->foreign('user_id') // указываем, что это будет внешний ключ
          ->references('id') // который ссылается на поле id
          ->on('users') // в таблице users
          ->onDelete('cascade'); // и при удалении пользователя, все его задачи тоже удалятся
      });
   "]

   # laravel Elaquend
      'find'
      "->pluck('trigger')"
      ##
      "->firstWhere('trigger', 'milk')->created_at;
      //
      OR
      //
      ::where('trigger','milk')->value('created_at'));"

      "получить все колонки из таблицы"
      ["$columns = Schema::getColumnListing('table_name');"]

   # time: 7200 =  2h * 60m * 60s

   # docker-compose commands:
   ['docker-compose down -v']
   ['docker-compose ps -a']
   ['docker-compose images']
   ['docker rmi $(docker images -q)']
   ['docker-compose build']
   ['docker-compose up -d']
   ['docker-compose build && docker-compose up -d']


   # SQL
   ['
      INSERT INTO table_name (column1, column2, column3)
      VALUES (value1, value2, value3);
   ']

   # Laravel commands
   ['
      php artisan db:seed --class=Seeder
      or
      php artisan db:seed  вызывает все сидеры которые указанны в DatabaseSeeder

      $columns = Schema::getColumnListing(missions); получает список названий колонок

      $mission->getAttributes()  получает все атрибуты массива

      Artisan::call(migrate:fresh);
      Artisan::call(db:seed);

         $allFieldsFilled = collect($lastMission->getAttributes())->except(column_name)->every(function ($value) {
            return isset($value) && ($value !== '');
        });

         $allFieldsFilled = collect($lastMission->getAttributes())->every(function ($value) {
            return !empty($value);
        });

        $columnType = Schema::getColumnType($table->getTable(), $field); проверка типа поле в БД

   ']

   # Regular
   ['
      
   ']


   # Buttons for Telegram Bot [ inline_keyboard & keyboard ]

   ['

      # 1
           [button][button]
 
         [
            "inline_keyboard" => 
            [
                [
                    [
                        "text" => "My Button 1",
                        "callback_data" => "/mycallback1"
                    ],
                    [
                        "text" => "My Button 2",
                        "callback_data" => "/mycallback2"
                    ]
                ]
            ]
        ];

      # 2
            [button][button]
         
         [
              "inline_keyboard" =>
            [
                 [
                     [
                         "text" => "✅",
                         "callback_data" => "100"
                     ],
                     [
                         "text" => "❌",
                         "callback_data" => "-100"
                     ]
                 ]
             ]
         ];

      # 3
         [button]
         [button]
         [
            "inline_keyboard" =>
            [
                [
                    [
                        "text" => "My Button 1",
                        "callback_data" => "/mycallback1"
                    ]
                ],
                [
                    [
                        "text" => "My Button 2",
                        "callback_data" => "/mycallback2"
                    ]
                ]
            ]
        ];


      # 4 keyboard on tap
      [
        keyboard => 
        [
            [Button 1], 
        ], 
        resize_keyboard => true, 
        one_time_keyboard => true
      ]

   ']




   #########################




   version: "3.8"

services:
  nginx:
    image: "nginx:stable-alpine"
    ports:
      - "443:443"
    container_name: nginx
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf
      - ./src:/app
      - /etc/letsencrypt/live/awawel.fun-0001/fullchain.pem:/etc/nginx/cert/fullchain.pem:ro
      - /etc/letsencrypt/live/awawel.fun-0001/privkey.pem:/etc/nginx/cert/privkey.pem:ro
    depends_on:
      - mysql
      - php

  php:
    build:
      context: dockerfiles
      dockerfile: php.Dockerfile
    container_name: php
    volumes:
      - ./src:/app

  mysql:
    image: mysql:8.0
    ports:
      - "3306:3306"
    env_file:
      - env/mysql.env
    # environment:
      # - TZ=Europe/Moscow
    volumes:
      - /home/lox/html/backup_mysql:/var/lib/mysql
      # - db_data:/var/lib/mysql
    container_name: mysql

  # mysql_test:
  #   image: mysql:8.0
  #   ports:
  #     - "3307:3306"
  #   env_file:
  #     - env/mysql_test.env
  #   container_name: mysql_test

  composer:
    build:
      context: dockerfiles
      dockerfile: composer.Dockerfile
    container_name: composer
    volumes:
      - ./src:/app

  cron:
    build:
      context: .
      dockerfile: dockerfiles/cron.Dockerfile
    container_name: cron
    volumes:
      - ./src:/app

volumes:
  db_data:

   